1/46 © Dave Houtman 2024
MODULE 07:
USING PRIMITIVE
TYPES
Professor : Dave Houtman
Office Hrs : Th: 14:15 – 15:15
(T323) F: 12:15 – 13:30
Email: houtmad@algonquincollege.com
2/46 © Dave Houtman 2024
Java is a strongly typed language (sometimes also described as a type-safe language),
meaning that it enforces the consistent declaration and use of specific data types at the time
they’re compiled in code.
7.0 Data Types
By contrast, weakly-typed languages allow the programmer to use the value of one type as if
it were of a different type. For example, the string value "1" might be treated the same as the
numerical value 1, which may also be treated in logical expressions as ‘true’. So an
expression that resolves to "1" could be treated as the number 1, the number 49, the string
“1" or the logical value ‘true’; the program decides at run time how to treat the expression
based on its context.
Strong typing helps ensure that errors will be caught at compile-time, rather than later, at
run-time, when these errors might be more extensive, harder to debug, and potentially
disastrous. (Imagine a rocket in flight, or a working nuclear power station; would you sooner
detect software bugs before the device became operational, or afterward?)
Note that Java has, as of version 10, a var data type that serves this purpose. But this should
be avoided as it defeats much of what makes Java so reliable for enterprise applications.
3/46 © Dave Houtman 2024
Java’s data types can be classified as either primitive types or reference types (using
reference/id values, which we saw in the previous module). Unlike the latter, primitive types
store values directly into memory, rather than use an id value as a reference to another place
in memory.
7.0 Data Types
Primitive Types
boolean
char
byte
short
int
long
float
double
Reference Types
everything
instantiated,
e.g.
Scanner
String
Date
Student
etc.
4/46 © Dave Houtman 2024
7.1 Primitive Data Types ⌘
Details of Java’s eight primitive data types are shown below.
Type Size (bytes) Classification Range
boolean (platform
dependant)
Logical true or false
char 2 Character '\u0000' to '\uFFFF'
byte 1 Numeric
(Integral)
-128 to +127
short 2 “ -32768 to +32767
int 4 “ -2147483648 to +2147283647
long 8 “ –9,223,372,036,854,775,808 to +9,223,372,036,854,775,807
float 4 Numeric
(decimal)
–3.4028235E+38 to –1.4e–45
1.4e–45 to 3.4028235E+38
double 8 “ –1.7976931348623157E+308 to –4.9e–324
4.9e–324 to 1.7976931348623157E+308
5/46 © Dave Houtman 2024
Note:
1. Primitive types always begin with a lowercase character. They are all reserved words in
Java, so they cannot be used as identifiers elsewhere in code.
7.1 Primitive Types
a) size – the number of bytes required to hold the type
b) range – the span of values that can be stored. The range is a direct reflection of
the size, since more bytes can store larger positive and negative values
c) precision – the number of digits of accuracy in the type. For integral data types,
including boolean, char, byte, short, int, and long, precision is absolute: a
number like 255 is exactly equal to 255. For either of the two decimal types, the
precision is typically not better than ±1 in the last decimal place.
d) format – all data is stored internally as ‘1’s and ‘0’s, including characters, boolean
values and decimal types. Different standards determine how Java interprets these
binary values. For example, decimal types are stored according to the IEEE 754
standard. Two-byte chars are stored according to the Unicode standard.
2. Each primitive type is characterized by four features:
6/46 © Dave Houtman 2024
Note (con’t):
3. For each primitive data type, Java has an equivalent wrapper class, i.e. a class (i.e.
reference) type version of the primitive type. So for the int type, there is an Integer
type, for the boolean primitive types, there is a Boolean type, etc. (each beginning with
a capital letter). Do NOT confuse the two; do not write:
Integer age = 24; if what you meant was int age = 24;
Wrapper classes will be used more frequently next semester. For now, do not use
wrapper types in declarations (as above left), or as arguments to methods, as this may
given unexpected results..
7.1 Primitive Types
4. Wrapper classes do have some useful methods and properties, which you can put to use
now, in this course. For example, to convert from a String to a value, use the wrapper
type’s valueOf() method. So if you have stored a value as a number using String num =
"42"; and you wish to know its integer value, use Integer.valueOf(num) to return an
int value.
7/46 © Dave Houtman 2024
7.1 Primitive Data Types ⌘
Note (con’t):
5. Some of the more useful methods and values associated with primitive types are listed
below.
Type Default value on
instantiation*
Input to Scanner
using:
Minimum/Maximum values
(including Wrapper classes constants)
boolean false nextBoolean() N/A
char '\u0000' (none) Character.MIN_VALUE Character.MAX_VALUE
byte (byte)0 nextByte() Byte.MIN_VALUE Byte.MAX_VALUE
short (short)0 nextShort() Short.MIN_VALUE Short.MAX_VALUE
int 0 nextInt() Integer.MIN_VALUE Integer.MAX_VALUE
long 0L nextLong() Long.MIN_VALUE Long.MAX_VALUE
float 0.0f nextFloat() Float.MIN_VALUE Float.MAX_VALUE**
double 0.0d nextDouble() Double.MIN_VALUE Double.MAX_VALUE**
* Some of the information in this column was presented earlier during the discussion on object instantiation. This is a more comprehensive
listing of the default values of primitive types.
** The min and max values of decimal types range from the smallest positive (non-zero) value to the largest positive value. To determine the
negative min/max ranges, use the negative value of the positive ranges.
8/46 © Dave Houtman 2024
boolean
• the boolean type has only two possible values: true and false (both keywords as
well). So you can set e.g.
boolean loop = true; or boolean loop = false;
but only one or the other; there is no such thing as boolean loop = 0;





7.1 Primitive Data Types (specifics)
• You can output the value stored in a boolean variable using
System.out.println(loop); // outputs the words true or false to the screen
• The actual size of a boolean varies with the implementation; it may occupy only a
single bit of space in memory, or a byte or more—it depends on the manufacturer of
the JVM
• boolean values are used extensively in logic expressions and loops, a subject to be
covered in the next module. For now, you can safely ignore the boolean data type.
9/46 © Dave Houtman 2024
char
• Each char is stored in a two-byte value. Internally, a char is just a number (as is every
data type). But when a variable is declared as a char, Java knows that it must treat
that value (a number between 0 to 65,535) as a character to be displayed;
7.1 Primitive Data Types (specifics)
• The ASCII character set is mapped into the first 256 characters of the Unicode
character set (available at https://www.unicode.org/standard/standard.html),
helping ensure backward compatibility with the older standard;
• A value assigned to a char data type can be declared as a number or a single
character expressed in single quotes, e.g.
char startUpperCase = 'A'; or char startUpperCase = 65;
This works because the ASCII uppercase characters A – Z start at 65; the lowercase
characters start at 97. To access Unicode characters with larger values, it is common
to use hexadecimal values, signaled using the '\uXXXX' escape sequence:
char PI = '\u03c0'; // Unicode value for the character π
10/46 © Dave Houtman 2024
char
• Because char’s are just numbers, you can do simple integer math on the character
data type. For example, if we create the method:
public static void printCharNumber(char upperCaseChar){
int nthCharOfTheAlphabet = upperCaseChar - 'A' + 1;
System.out.println(upperCaseChar + " is the " +
nthCharOfTheAlphabet + "th character of the alphabet.");
}
7.1 Primitive Data Types (specifics)
then we can call this method by passing a character value to it:
char alphabetChar = 'D'; // D has value 68
printCharNumber(alphabetChar); // outputs "D is the 4th character
// of the alphabet."
printCharNumber('Z'); // outputs "Z is the 26th character
// of the alphabet."
11/46 © Dave Houtman 2024
char
• You cannot assign a character value to a String (or a String to a character for that
matter). Thus the following are legal:
String s = "A"; // Strings use double quotes, " "
char c = 'A'; // chars use single quotes, ' '
while the following are not:
String s = 'A'; // Strings do not use ' '
char c = "A"; // chars do not use " "
7.1 Primitive Data Types (specifics)
Note: Getting a special character to display on the console screen may depend on how Eclipse is
configured. If a character does not appear in the console as expected, select Run >> Run Configurations…
>> Click the Common Tab >> Click the ‘Other’ radio button >> Select UTF-16 and see if this character set
will output the desired value.
12/46 © Dave Houtman 2024
char
• Earlier on we introduced character escape sequences such as \n and \t, which are
used by print() to control string output. But if the ‘\’ character is used internally
by print(), how do you output the ‘\’ character itself? Similarly, if " " are used to
indicate a string, how do you output the " character to the console? Fortunately,
you can ‘escape’ escape characters…
7.1 Primitive Data Types (specifics) ⌘
Escape
sequence
Description
\n adds a new line to the end of the output stream
\t inserts a tab; actual output varies depending on how the tabs are set
\\ inserts a \ into the string
\" inserts a " into the string
\' inserts a ' into the string
13/46 © Dave Houtman 2024
byte, short, int, long
• These are integral types, i.e. they are used to store whole numbers, i.e. those lacking
fractional or decimal components, such as the number of students, the number of
planets, or the population of a country;
7.1 Primitive Data Types (specifics)
• These data types automatically hold both positive and negative values; there is no
need to indicate that they are ‘signed’ or ‘unsigned’ as in many C-based languages;
• As indicated earlier, byte-sized variables only store values up to 127; shorts store
numbers up to 32767, etc. In general we might describe the situation as:
byte < short < int < long
So the following are not possible: byte b = 365; short s = 1024768. In both
cases, the numerical values exceed the maximum allowed size based on the bytes
available.
• If you need to store numbers larger than a long value, there is a special class (i.e. a
reference type) called BigInteger, capable of storing extraordinarily large integer
values—but at considerable cost in execution speed.
14/46 © Dave Houtman 2024
byte, short, int, long
• In Java, attempting to add 1 to the largest allowed value for ints and longs will NOT
trigger an overflow exception. For example, in the following code, we load the
largest possible value into an int, and then increase its value twice more. There is no
exception thrown! It is the user’s responsivity to test the code against potential
overflow situations.
7.1 Primitive Data Types (specifics)
15/46 © Dave Houtman 2024
byte, short, int, long
• Any arithmetic involving bytes and shorts is automatically converted to the int
data type. For example, in the code below, when we add one to the maximum value
that can be stored in a short, rather than overflowing, integer addition is
performed, rather than using the short itself. In fact, it’s almost impossible to do
anything with bytes and shorts without converting them to the int type
automatically.
7.1 Primitive Data Types (specifics)
16/46 © Dave Houtman 2024
byte, short, int, long
• By default, whenever you assign an integral value to a variable, it is assumed the
number is an int by default, rather than a long, byte, or short.
• If you want to load a large ‘long-size’ number into a variable declared as long, you
must append ‘L’ or ‘l’ (lowercase L) to the number, i.e.
long populationOfEarth = 80847249266L; // as of Jan 24, 2024, 11:57 p.m.
The above works, but this does not:
long populationOfEarth = 80847249266; // number too large be held in an int!
7.1 Primitive Data Types (specifics)
Note that use of the lowercase ‘l’ is problematic in this case since the lowercase
character l is oftentimes virtually indistinguishable from the number 1 (one)—and
especially when the Courier typeface is used.
Can you spot the difference between 100l and 1001?. They are different.
17/46 © Dave Houtman 2024
float, double
• These two data types store decimal values, those holding decimal and exponential
components.
7.1 Primitive Data Types (specifics)
• Java allows exponential values to be written in the form ‘1.234E7’, where everything
after ‘E’ (or lowercase ‘e’) indicates the power of the exponent. So 1.234E7 is just
1.234 X 107
, or 12,340,000.0, as doubles (see next slide)
• Just as you can use ‘L’ (or ‘l’) to signal a long value, Java allows the user to specify
float and double values using ‘F’ (or ‘f’) and D (or ‘d’) after the number,
respectively. For example:
float radiusOfGalaxy = 4.95E17F; // radius of galaxy = 4.95 X 1017 km
double radiusOfUniverse = 4.4E23D; // radius of universe 4.4 X 1023 km
• Just as there is a BigInteger class to handle super-large integers, there is a
BigDecimal class to handle decimal/exponential values of almost any size
18/46 © Dave Houtman 2024
float, double
• Just as integral numbers default to ints, decimal values default to a double. Thus
the following is incorrect:
float atomsPerMole = 1.6E23; // Avagadro’s number
The number on the right defaults to a double value (8 bytes) while the declaration
on the left is for a float (4 bytes)—rather like trying to park a truck in a space
intended for a bicycle. But the following works, because we tell the compiler to treat
the decimal value as a 4-byte float, and so everything fits:
float atomsPerMole = 1.6E23F; // make number a float
7.1 Primitive Data Types (specifics)
• While integral values are exact—there is no such thing as a fraction of a planet—
decimal values have an associated uncertainty because the memory used to hold the
value is finite. This can lead to problems when comparing two decimal values that
should, mathematically, have the exact same value, but do not. More on this
shortly.
19/46 © Dave Houtman 2024
float, double
• Unlike integral values, floating point numbers don’t ‘wrap around’ when they get too
large. Nor do they signal an error. Rather, the values POSTIVE_INFINITY and
NEGATIVE_INFINITY are used to indicate the number has become too positive or
too negative to be held in the data types (see output below). And undefined values,
such as 0.0/0.0 are treated as NaN—’not a number’.
7.1 Primitive Data Types (specifics)
20/46 © Dave Houtman 2024
float, double
• Floating-point types suffer from round-off errors, as demonstrated below:
public class FloatingComparisonDemo {
static final double EPSILON = 1E-14; // set to a very small number
// 1E-14 means 0.00000000000001
public static void main(String[] args) {
double num = 0.1 + 0.1 + 0.1; // does not equal 0.3 internally
System.out.println("num is: " + num); // num is 0.30000000000000004
System.out.println(num == 0.3); // not exactly equal; outputs false
System.out.println( Math.abs(num - 0.3) <= EPSILON ); // outputs true
}
}
7.1 Primitive Data Types (specifics)
Note that
Math.abs(num - 0.3) <= EPSILON
means that the actual value of num must
be within plus or minus EPSILON from 0.3:
num
0.2999…9 0.3 0.30000…1
-EPSILON +EPSILON
21/46 © Dave Houtman 2024
Where a variable is declared affects its scope, that is, its visibility inside the program. For
example, in the code below, the variable volumeOfPlanet has class-level scope and hence
is visible throughout the class. By comparison, the radius of Jupiter is declared inside
main(), and hence it is only visible in main(): it has local scope.
public class Planet {
public static double volumeOfPlanet = 0;
public static void main(String [] args){
double radius = 6.9911E4; // radius of Jupiter
.
.
.
volumeOfPlanet = getVolumeOfSphere(radius);
.
.
.
}
}
7.2 Scope
Local Scope
Class
-level Scope
22/46 © Dave Houtman 2024
The public access modifier before volumeOfPlanet affects who can see/use that variable
externally; but that’s not the same thing as who gets to use it internally. If that variable is
declared private, it’s scope remains the same, but it cannot now be accessed externally by
other code.
public class Planet {
private static double volumeOfPlanet = 0;
public static void main(String [] args){
double radius = 6.9911E4; // radius of Jupiter
.
.
.
volumeOfPlanet = getVolumeOfSphere(radius);
.
.
.
}
}
7.2 Scope
Local Scope
Class
-level Scope
23/46 © Dave Houtman 2024
Simply because two variables have the same name does not mean they correspond to the
same place in memory—if their scope if different. In the example below, changing the value
of radius inside getVolOfSphere() has no effect on the value stored in the outer class:
public class PlanetLauncher {
private static double volumeOfPlanet = 0;
public static void main(String[] args){
double radius = 6.9911E4; // radius of Jupiter
volumeOfPlanet = getVolOfSphere(radius); // pass Jupiter’s radius
System.out.println("Value of local radius is still: " + radius);
} //unchanged…
private static double getVolOfSphere(double radius){
double radius = 3.3895E3; // override radius to use Mars’s radius
double volume = (4.0/3) * Math.PI * Math.pow( radius, 3 );
return volume; // return result of calculation
} // …using Mars’s radius, not Jupiter’s radius
}
7.2 Scope
This radius
identifier has
scope local to
main() only
This radius has scope local to
getVolOfSphere() only
A copy of main()’s radius is passed to
getVolOfShere() and loaded into the
local variable radius
24/46 © Dave Houtman 2024
The same rules apply if two variables have the same name in different classes. ‘radius’ in
main() is not the same radius as declared in a class instantiated into an object:
public class PlanetLauncher {
private static double volumeOfPlanet = 0;
public static void main(String[] args){
double radius = 6.9911E4; // radius of Jupiter
Planet jupiter = new Planet(radius); // pass copy of Jupiter’s radius
volumeOfPlanet = jupiter.getVolOfSphere();
System.out.println("Value of radius is still: " + radius);
}
}
7.2 Scope
public class Planet {
private double radius;
public Planet(double radius){this.radius = radius;} // constructor
public double getVolOfSphere(){
double volume = (4.0/3) * Math.PI * Math.pow(radius, 3);
radius = 2.4397E3; // if you mess with the radius stored in
return volume; // class Planet, it has no effect on the
// original value of radius declared in
} // main()
}
copy radius into radius
copy radius into this.radius
25/46 © Dave Houtman 2024
Five basic math operations allow for the manipulation of the values stored in our variables:
Symbol Operation Example Value
+ Addition int initialEggs = 47;
int totalEggs = initialEggs + 17;
47
64
- Subtraction int brokenEggs = 5;
totalEggs = totalEggs – brokenEggs;
5
59
* Multiplication
int eggCartons = 5;
int eggCapacity = eggCartons * 12;
5
60
/ Division int dozensOfEggs = totalEggs / 12; 4
% Modulus
(Remainder)
int leftoverEggs = totalEggs % 12; 11
7.3 Math Operations
26/46 © Dave Houtman 2024
In all Java mathematical operations, the computation on the right-hand side (RHS) of the equals
(=) sign is always performed first, and only then assigned to the identifier on the left-hand side
(LHS—more on this in Module 08). So for example, the statement
totalEggs = totalEggs – brokenEggs;
says: perform the calculation on the RHS (first) and assign that value to the LHS.
So given totalEggs = 64 and brokenEggs = 3 initially, the result of this expression is
totalEggs = (64) – (3) // totalEggs – brokenEggs
= 61; // the new value stored in totalEggs
i.e. the value of the total number of (usable) eggs is now adjusted down to 61.
Note that calculations on the RHS are always assigned to the LHS, never the reverse. So the
following is illegal and will generate a compile-time error:
totalEggs + newEggs = totalEggs; // calculation must be performed on the RHS only
7.3 Math Operations
27/46 © Dave Houtman 2024
It frequently happens that we wish to reset the value of a variable based on its older or previous
value. In such cases it is preferable to use one of Java’s shortform operations for this purpose.
As the word suggests, these are merely shorter versions of common mathematical operations in
which a variable is reassigned a new value based on its older value through addition, subtraction,
division, multiplication, or the modulus.
Shortform Operator Example Equivalent Operation
+= x += 3; x = x + 3;
-= x -= 6; x = x - 6;
/= x /= y; x = x / y;
*= x *= x; x = x * x;
%= x %= 3; x = x % 3;
7.4 Shortform Operators
28/46 © Dave Houtman 2024
Note the general form of the shortform operator: the variable on the LHS is repeated on the RHS
followed by the math symbol used, then the value originally on the RHS:
7.4 Shortform Operators
doubleUp doubleUp *= 2;
incrVar += 1;
countDn -= 1;
halve / halve = 2;
monthNm %= 12;
29/46 © Dave Houtman 2024
It is a common requirement, particularly in loops (addressed in Module 10), to increment a
value by 1 each time through the loop. We’ve already seen two ways to increment a value by 1:
int loopCtr = 0; // initialize counter to 0
loopCtr = loopCtr + 1; // 1st method: increment by 1
loopCtr += 1; // 2nd method: add another 1
To this we add a third, shorter method:
++loopCtr; // 3rd method: incr by 1 again!
7.5 Prefix and Postfix
30/46 © Dave Houtman 2024
The ++ before the variable is known as the prefix operator—it ‘fixes’ the value by adding 1 to
the variable. There is also a postfix operator:
loopCtr++; // increments by 1, but differently
This also increments loopCtr by 1, but in a way subtly different than the prefix operator. We’ll
address these differences later. For now, treat this as yet another way to increment a variable
by 1. (Note that none of these operations is limited to integral values; you can use them with
decimal values as well.)
7.5 Prefix and Postfix
As well, there are prefix and postfix decrements, written
--loopCtr; // decrements the value in loopCtr by 1
loopCtr--; // also decrements loopCtr by 1
Both expressions decrease the value by 1, but again with subtle differences. For now, treat the
two decrements as equivalent, and equal to loopCtr -= 1; and loopCtr = loopCtr – 1;
31/46 © Dave Houtman 2024
There are times when Java needs to perform a conversion between different data types. When
the conversion is from a smaller-sized data type to a larger data type—known as a widening
conversion—this is usually not problematic. So the following are permitted:
long lValue = 9979; // the RHS contains an int by default,
// which is smaller than a long
int alphaValue = 'c'; // char is smaller than an int
float age = 42; // the integer 42 is converted to 42.0f
double newAge = age; // the float is converted to 42.0d
In each case the smaller-sized value on the RHS is implicitly converted to the larger data type
declared on the LHS. Such implicit type conversions happen automatically, without the
programmer’s intervention.
7.6 Implicit Type Conversion
32/46 © Dave Houtman 2024
Implicit conversion is governed by the following chart. Any type declared below can always
store a value to its left*:
*adapted from Cay S. Horstmann, Core Java—Volume 1 Fundamentals, 10th ed. Pg. 59
7.6 Implicit Type Conversion ⌘
byte short int
char
float double
long
Dashed lines indicate a potential loss
of precision in the conversion. For example:
int n = 123456789; // int has 9 digits of precision
float f = n; // float has 8; the value stored is 1.23456792E8
33/46 © Dave Houtman 2024
Implicit type conversions also occurs during math operations. When two values of different type
are used, the result of the expression is automatically converted up to the wider of the two
types. For example, assume
int i1 = 1; int i2 = 2; long L1 = 1000; float f1 = 3.84f; double d1 = 1.24;
then:
i1 + i2 3 // int plus int results in an int
i1 + L2 1001 // int plus long results in a long value
f1 * i2 7.68 // float times int results in a float value
d1 * L1 3.84E3d // double times long results in double value
f1 / d1 3.096774194 // float by double results in a double value
7.6 Implicit Type Conversion
34/46 © Dave Houtman 2024
Implicit casting can sometimes lead to misleading results. For example, consider the following
method, designed to return the ratio of two integer values as a floating-point value:
float calculateRatio (int numerator, int denominator) {
float result = numerator/denominator;
return result;
}
The test table for this method gives the following results. It looks good. But what’s missing?
7.6 Implicit Type Conversion
Input Expected output Actual output Description
-8
-4
2.0 2.0 Test two negative
values
-1
0
throws
ArithmeticException
throws
ArithmeticException
Divide by zero with
negative num
0
1
0.0 0.0 Test with 0 in the
numerator
9
-3
-3.0 -3.0 Positive numerator,
negative denominator
10
2
5.0 5.0 Test two positive
ints
35/46 © Dave Houtman 2024
Note that automatic type conversions also play a role in which signature will be used to call an
overloaded constructor. For example, assume the following constructors exist:
If there is no int constructor, the first instantiation calls the Country(long) constructor. If
the Country(long) constructor does not exist, then both new Country(9984670) and new
Country (9984670L) will call the Country(float area) constructor.
And note that calling new Country(9.984670E6) triggers an error (Why?)
7.6 Implicit Type Conversion
Country(long area) Country(float area)
new Country(9984670)
new Country(9984670L)
new Country(9.984670E6)
new Country(9.984670E6F)
Country(int area)
36/46 © Dave Houtman 2024
It is sometimes necessary to cast a number to a different data type using, for example
float result = (float)numerator/denominator;
This says to widen the integer value of numerator to a float. A float divided by an int will
result in a float, and so the calculation on the RHS will be performed correctly before the
result is loaded on the LHS.
Note that the cast is applied to the identifier first, before the division is performed: the casting
operation has precedence over the math operation.
7.7 Explicit Type Conversion
Note that it is not possible to cast a value to a boolean type
37/46 © Dave Houtman 2024
As we saw earlier, to prevent or minimize data loss, the compiler will not automatically convert
larger data types into smaller ones. However, the programmer can choose to perform a
narrowing conversion or downcast. We saw an example of this earlier:
int ageInYrs = (int)(ageInMilliSeconds / (1000 * 3600 * 24 * 365.25));
7.7 Explicit Type Conversion
Consider the data
types used, and
the conversions
that occur:
we multiply int values by a
double value; the result is
implicitly upcast to a double ageInMilliSeconds
is a long value
the division of a long by a double is
implicitly cast to a double
we explicitly downcast to an int value
to load the ageInYrs variable
38/46 © Dave Houtman 2024
Downcasting should be avoided whenever possible since the results can be unpredictable. For
the above equation, a quick calculation indicates that, at worst, it would fail in about 8.3 million
years —too long to worry about, and too small a value to risk overflowing the int data type.
int ageInYrs = (int)(ageInMilliSeconds / (1000 * 3600 * 24 * 365.25));
Use of a double value in the calculation (in the form of 365.25) means that the actual time-tofail is considerably greater, but at the cost of some accuracy. So this downcast is probably not
dangerous in our application—however there are more reliable ways to perform the same
calculation.
7.7 Explicit Type Conversion
39/46 © Dave Houtman 2024
Here are two other examples that use a narrowing conversion, from a four-byte int to a twobyte char:
char convertToLowerCase(char upperCaseChar) {
char lowercaseChar = (char)(upperCaseChar + 32);
return lowercaseChar;
}
char convertToUpperCase(char lowerCaseChar) {
char uppercaseChar = (char)(lowerCaseChar - 32);
return uppercaseChar;
}
Again, the downcast from an int to a char is not dangerous here, provided we check to
ensure that only appropriate ASCII-valued alphabetic chars are passed to the methods—a
subject for later on in this semester, and for the following semester as well.
7.7 Explicit Type Conversion
40/46 © Dave Houtman 2024
To create a constant value—one which cannot be altered in code once set—use the keyword
final. For example:
final float ABSOLUTE_ZERO = -273.15; // in degrees Celsius
final int VOTING_AGE = 18;
final int GOLD = 1, SILVER = 2, BRONZE = 3;
Note:
• As mentioned earlier, constant values should use all upper-case, separated by ‘_’
• Parameters can be passed as final, so they are locally constant, inside a method.
• final is often used with static, since values which are universally constant only need
to be declared in one place in the program. A value which was final but not static is
constant but visible only within its scope. A value which is static but not final, as
we saw earlier, is loaded first, and only once, but can be altered if its visibility is public
• A value declared as final can be recast to a different value, e.g. double ZERO =
(double)ABSOLUTE_ZERO; But that doesn’t affect the original value,
ABSOLUTE_ZERO, which is still a float decimal type equal to -273.15.
• Reference values can be declared final, meaning their value cannot change, i.e. they
cannot be loaded with a new object’s id
7.8 Using final to Define Constants
41/46 © Dave Houtman 2024
Declaring constants in code, rather than using their values directly, is good practice, since it
avoids the use of magic numbers. A magic number is any value that is context dependent,
perhaps known only to the programmer. For example:
public getSalesTax (double cost){
double totalTax = 0.13 * cost; // where did 0.13 come from?
return totalTax;
}
To the casual observer, the value 0.13 is a magic number: what does it refer to?
7.8 Using final to Define Constants
42/46 © Dave Houtman 2024
If we give 0.13 a constant identifier—and proper documentation— then it becomes clear what the
number means:
public static final double HST = 0.13; // Harmonized Sales Tax (HST) is 13%
public getSalesTax (double cost){
double totalTax = HST * cost;
return totalTax;
}
This has the added benefit that should the tax rate change in the future, that value will only need
to be changed once in the code, where it is declared, rather than every place where the value
‘0.13’ appears.
7.8 Using final to Define Constants
43/46 © Dave Houtman 2024
Questions
1. Assume the following :
short s = (short)200;
int i = 200;
float f = 4.0f;
double d = 800000.00000000;
What value and data type would result from each of the following calculations?
a) i/s 1 (int)
b) i/f 50.0 (float)
c) i*(int)f 800 (int)
d) (int)d * f 3200000.0 (float)
e) (short)(d*f) -11264* (short)
*Why -11264? 3200000 = 30D400 h. D400h (the lowest 2 bytes) = -11264
44/46 © Dave Houtman 2024
2. What is the difference between the following two outputs
int num1 = 56;
float num2 = 23.2f;
System.out.println("1st output: num1 + num2 = " + (num1 + num2));
System.out.println("num1 + num2 = " + num1 + num2);
1st output: num1 + num2 = 79.2
2nd output: num1 + num2 = 5623.2
Questions
3. A programmer writes a method to calculate the percentage on an exam based on the
marks students get right and the total value of each exam. The output is supposed to be
an integer value, but every time he runs the program he gets 0, except on rare occasions.
(a) Here’s the code; explain the problem:
public int calculatePercent(int correctResults, int totalTestMark){
int result = 100 * (correctResults/totalTestMark);
return result;
}
(b) Under what circumstances is the result calculated by this method correct?
(c) What steps could be taken to fix the problem (list two)?
45/46 © Dave Houtman 2024
4. A junior programmer is asked to write a method that adds two positive int values
together, and returns their sum, provided it is less than Integer.MAX_VALUE. If the
sum is greater than Integer.MAX_VALUE, the method returns 0.
The programmer writes the following code:
private static int add(int num1, int num2) {
if (num1 + num2 > Integer.MAX_VALUE)
return 0;
else
return (num1 + num2);
}
(1) Explain why this program will not work as intended
(2) Explain how you would fix the math so that the method worked correctly
Questions
46/46 © Dave Houtman 2024
5. Using the equation for the volume of a sphere (V = (4/3)πr
3
), a programmer calculates
the volume of a sphere of a given radius using
public double getSphereVolume(double radius){
double volume = (4/3) * Math.PI * Math.pow(radius,3);
return volume;
}
but this consistently gives incorrect results, as seen in the test table below. List three
easy ways to fix this problem.
Questions
Input Expected output Actual output Description
0 0 0 0 radius gives 0 volume, as expected
2 33.51032163 25.13274123 Test int input; result different than expected;
actual output is ¼ less than expected value
2.5 65.44984697 49.08738522 Test of double value; actual value returned is
¼ less than expected
3.2 137.2582774 102.9437081 Test of another, larger double; same problem
with calculation as indicated above